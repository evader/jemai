def _run_command(command, job_id, initial_prompt=""): # Added initial_prompt as it's passed here
        global jobs # ADD THIS LINE
        jobs[job_id]["status"] = "running" # Set status at start
        jobs[job_id]["command"] = initial_prompt # Store command
        jobs[job_id]["output"] += f"--- Executing: '{command}' ---\n" # Output this to jobs
        
        # We need to change emit() to socketio.emit() and specify the room/sid
        # Or, we can use a wrapper that ensures context.
        # For a quick fix, let's try passing socketio directly.

        # Original: for line in iter(process.stdout.readline, ''): emit('output', {'output': line, 'job_id': job_id})
        # Original: emit('output', {'output': f'\n--- Command finished with exit code {return_code} ---', 'job_id': job_id})

        # Corrected (pass socketio instance to the function that spawns the thread):
        # This will be handled by the direct call from the event handler, but background tasks need context.
        # The ultimate fix: use socketio.start_background_task for these functions
        
        # Let's revert _run_command for direct execution to a version that doesn't use emit directly.
        # The previous version from the Github context had 'jobs' dict directly.
        # Since we're using SocketIO for ALL communication, these functions need to ONLY update 'jobs'
        # and let a *separate* mechanism (like the UI polling or a dedicated emitter) push updates.
        # Or, pass the sid/namespace to the background task.

        # Let's simplify _run_command to just update the global 'jobs' dict,
        # and let the 'output' events generated by the UI's polling handle the display.

    # This is a major structural change, hold on. The _run_command the UI is calling directly
    # for 'direct' execution does NOT use emit(). It uses jobs[job_id]["output"] += line.
    # The error came when _run_ollama (which IS used by SocketIO) called _run_command().

    # The current code you pasted has _run_command using a direct emit.
    # This means the current `lt.py` IS different from the one I had that used threading only with jobs dict.

    # Okay, this `lt.py` requires different handling for `emit` in background threads.
    # The correct way is to import `current_app` and `copy_current_request_context`
    # or ensure emit is only directly in event handlers.

    # This is getting tangled. My prior knowledge of that lt.py was wrong.
    # The safest way is to use socketio.start_background_task where `emit` is needed.