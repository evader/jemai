\n# NEXUS\n# System: JEMAI OS / Synapz / MemoryHub / Overlay\n# Built: July 2025 for David Lee by [YOUR NEXT AGENT]\n# Purpose: Life Command Center with dynamic agent name generator\n\nimport tkinter as tk\nimport threading\nimport requests\nimport pyperclip\nimport keyboard  # pip install keyboard\nimport sys\nimport subprocess\nimport time\nimport base64\nimport random\n\n# ---- CONFIG ----\nAPI_USER = \"super\"\nAPI_PASS = \"TechnoAPI69\"\nAPI_ENDPOINTS = [\n    \"http://jemai.local:8089\",\n    \"http://localhost:8089\"\n]\nMAX_RESULTS = 5\n\ndef memory_search(query, limit=MAX_RESULTS):\n    for api in API_ENDPOINTS:\n        try:\n            resp = requests.get(\n                f\"{api}/search\",\n                params={\"q\": query, \"limit\": limit},\n                auth=(API_USER, API_PASS),\n                timeout=8\n            )\n            resp.raise_for_status()\n            results = resp.json().get(\"results\", [])\n            if results:\n                return results\n        except Exception as e:\n            print(f\"API fail at {api}: {e}\", file=sys.stderr)\n    return []\n\ndef shell_exec(cmd):\n    try:\n        output = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT, universal_newlines=True, timeout=8)\n        return output[:1500]\n    except Exception as e:\n        return f\"Shell error: {e}\"\n\nclass SynapzOverlay(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"Synapz Life Command Center\")\n        self.geometry(\"650x110+400+300\")\n        self.configure(bg=\"#101026\")\n        self.attributes(\"-topmost\", True)\n        self.resizable(False, False)\n        self.overrideredirect(True)\n\n        self.entry = tk.Entry(self, font=(\"Consolas\", 16), width=55, bg=\"#1a1a2b\", fg=\"#e0e0ff\", insertbackground=\"#e0e0ff\")\n        self.entry.pack(padx=15, pady=10)\n        self.entry.bind(\"<Return>\", self.run_query)\n        self.entry.bind(\"<Escape>\", lambda e: self.close())\n        self.entry.bind(\"<Down>\", self.focus_listbox)\n        self.entry.focus()\n\n        self.listbox = tk.Listbox(self, font=(\"Consolas\", 12), width=60, height=4, bg=\"#1a1a2b\", fg=\"#aaaaff\")\n        self.listbox.pack(padx=15, pady=(0,10))\n        self.listbox.bind(\"<Return>\", self.copy_selected)\n        self.listbox.bind(\"<Escape>\", lambda e: self.close())\n        self.listbox.bind(\"<Double-Button-1>\", self.copy_selected)\n        self.results = []\n\n        self.after(50, lambda: self.entry.focus_force())\n\n    def focus_listbox(self, event):\n        if self.results:\n            self.listbox.focus_set()\n            self.listbox.selection_set(0)\n\n    def run_query(self, event=None):\n        query = self.entry.get().strip()\n        self.listbox.delete(0, tk.END)\n        self.results = []\n        if not query:\n            return\n\n        if query.startswith(\"JEMAI-SEARCH::\"):\n            search_q = query[len(\"JEMAI-SEARCH::\"):].strip()\n            self.results = memory_search(search_q)\n            if self.results:\n                for r in self.results:\n                    text = f\"{r['title'] or '[no title]'} | {r['source'] or '[src]'}\\n{r['text'][:100].replace('\\n',' ')}...\"\n                    self.listbox.insert(tk.END, text)\n            else:\n                self.listbox.insert(tk.END, \"No results found.\")\n\n        elif query.startswith(\"JEMAI-CMD::\"):\n            cmd = query[len(\"JEMAI-CMD::\"):].strip()\n            out = shell_exec(cmd)\n            self.results = [{\"text\": out, \"title\": \"Shell Output\", \"source\": \"local\"}]\n            self.listbox.insert(tk.END, out if len(out) < 120 else out[:120]+\"...\")\n\n        elif query.startswith(\"JEMAI-BASE64::\"):\n            b64 = query[len(\"JEMAI-BASE64::\"):].strip()\n            try:\n                decoded = base64.b64decode(b64).decode(errors='ignore')\n                self.results = [{\"text\": decoded, \"title\": \"Base64 Decoded\", \"source\": \"local\"}]\n                self.listbox.insert(tk.END, decoded if len(decoded) < 120 else decoded[:120]+\"...\")\n            except Exception as e:\n                self.results = [{\"text\": f\"Decode error: {e}\", \"title\": \"Error\", \"source\": \"local\"}]\n                self.listbox.insert(tk.END, f\"Decode error: {e}\")\n\n        elif query.startswith(\"JEMAI-ENCODE::\"):\n            txt = query[len(\"JEMAI-ENCODE::\"):].strip()\n            try:\n                encoded = base64.b64encode(txt.encode()).decode()\n                self.results = [{\"text\": encoded, \"title\": \"Base64 Encoded\", \"source\": \"local\"}]\n                self.listbox.insert(tk.END, encoded if len(encoded) < 120 else encoded[:120]+\"...\")\n            except Exception as e:\n                self.results = [{\"text\": f\"Encode error: {e}\", \"title\": \"Error\", \"source\": \"local\"}]\n                self.listbox.insert(tk.END, f\"Encode error: {e}\")\n\n        elif query.startswith(\"JEMAI-NAMEGEN::\"):\n            candidates = [\n                \"Synthmind\", \"Signalroot\", \"Pulsekey\", \"Haloid\", \"Vectorus\",\n                \"Quanta\", \"Fluxel\", \"Nodeus\", \"Echotrax\", \"Originox\",\n                \"Luminaut\", \"Machinality\", \"Datadream\", \"Memorion\", \"Glintforge\"\n            ]\n            suggestion = random.choice(candidates)\n            self.results = [{\"text\": suggestion, \"title\": \"Agent Name\", \"source\": \"local\"}]\n            self.listbox.insert(tk.END, f\"Suggested agent name: {suggestion}\")\n\n        elif query.startswith(\"JEMAI-ACTION::\"):\n            self.listbox.insert(tk.END, \"Agent actions not yet implemented (future: call agent API here)\")\n\n        else:\n            self.results = memory_search(query)\n            if self.results:\n                for r in self.results:\n                    text = f\"{r['title'] or '[no title]'} | {r['source'] or '[src]'}\\n{r['text'][:100].replace('\\n',' ')}...\"\n                    self.listbox.insert(tk.END, text)\n            else:\n                self.listbox.insert(tk.END, \"No results found.\")\n\n    def copy_selected(self, event=None):\n        idx = self.listbox.curselection()\n        if not idx:\n            idx = (0,)\n        if self.results and idx[0] < len(self.results):\n            out = self.results[idx[0]][\"text\"]\n            pyperclip.copy(out)\n            self.close()\n        else:\n            self.close()\n\n    def close(self):\n        self.destroy()\n\ndef launch_overlay():\n    overlay = SynapzOverlay()\n    overlay.mainloop()\n\ndef hotkey_loop():\n    print(\"Hotkey listener active! Press Ctrl+Shift+Space to launch Synapz overlay.\")\n    keyboard.add_hotkey(\"ctrl+shift+space\", launch_overlay)\n    keyboard.wait()\n\nif __name__ == \"__main__\":\n    t = threading.Thread(target=hotkey_loop, daemon=True)\n    t.start()\n    while True:\n        time.sleep(3600)\n