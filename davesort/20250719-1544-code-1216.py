\nimport subprocess\nimport os\nimport psutil\n\ndef run_shell_command(command):\n    try:\n        result = subprocess.run(command, shell=True, text=True, capture_output=True, timeout=10)\n        return result.stdout.strip() if result.stdout else result.stderr.strip()\n    except subprocess.TimeoutExpired:\n        return \"Command timed out.\"\n    except Exception as e:\n        return f\"Error: {e}\"\n\ndef get_system_summary():\n    try:\n        return {\n            \"cpu_percent\": psutil.cpu_percent(interval=1),\n            \"memory\": psutil.virtual_memory()._asdict(),\n            \"disk\": psutil.disk_usage(\"/\")._asdict(),\n            \"load\": os.getloadavg() if hasattr(os, \"getloadavg\") else \"Not available\"\n        }\n    except Exception as e:\n        return {\"error\": str(e)}\n\ndef check_process(process_name):\n    for proc in psutil.process_iter(['pid', 'name']):\n        if process_name.lower() in proc.info['name'].lower():\n            return f\"Found process {proc.info['name']} (PID: {proc.info['pid']})\"\n    return f\"Process '{process_name}' not found.\"\n\ndef list_top_cpu_processes(limit=5):\n    procs = [(p.pid, p.info['name'], p.cpu_percent(interval=0.1)) for p in psutil.process_iter(['name'])]\n    top = sorted(procs, key=lambda x: x[2], reverse=True)[:limit]\n    return [{\"pid\": pid, \"name\": name, \"cpu%\": cpu} for pid, name, cpu in top]\n