\nimport threading, time, queue, os, subprocess, glob, importlib.util, sys\nfrom pathlib import Path\ntry:\n    import requests\nexcept ImportError:\n    requests = None\n\nclass JemaiMaster:\n    # ... (rest unchanged above)\n    def __init__(self):\n        self.jobs = queue.Queue()\n        self.running = True\n        self.hostname = os.uname().nodename\n        self.skills = {}\n        self.rag_index = {}\n        self.rag_chunks = {}   # NEW: chunked docs\n        self.rag_path = Path(\"./rag_files\")\n        self.skills_path = Path(\"./skills\")\n        self._load_skills()\n        threading.Thread(target=self.rag_watcher, daemon=True).start()\n\n    # ... (rest unchanged above)\n\n    def cli_loop(self):\n        while self.running:\n            try:\n                cmd = input(\"\\nJEMAI> \").strip()\n                if cmd.lower() in (\"exit\", \"quit\"):\n                    self.running = False\n                    print(\"Shutting down JEMAI. Goodbye.\")\n                elif cmd:\n                    if cmd.split()[0] in self.skills:\n                        self.skills[cmd.split()[0]](\" \".join(cmd.split()[1:]))\n                    elif cmd.startswith(\"search \"):\n                        self.rag_search(cmd[7:])\n                    elif cmd.startswith(\"summarize \"):\n                        self.rag_summarize(cmd[10:])\n                    elif cmd.startswith(\"reason \"):\n                        self.reason_mode(cmd[7:])\n                    elif self.looks_like_shell(cmd):\n                        self.run_shell(cmd)\n                    else:\n                        self.run_ai(cmd)\n            except (KeyboardInterrupt, EOFError):\n                self.running = False\n\n    # ... (rest unchanged above)\n\n    # NEW: chunk doc files into self.rag_chunks for RAG\n    def rag_watcher(self):\n        print(\"[JEMAI] (RAG indexer watching for new files...)\")\n        self.rag_path.mkdir(exist_ok=True)\n        while self.running:\n            files = glob.glob(str(self.rag_path / \"*.txt\"))\n            for f in files:\n                if f not in self.rag_index:\n                    try:\n                        with open(f, \"r\") as fh:\n                            text = fh.read()\n                            self.rag_index[f] = text\n                            # Split into ~512-token chunks (here, crude: 2K chars per chunk)\n                            self.rag_chunks[f] = [text[i:i+2000] for i in range(0, len(text), 2000)]\n                            print(f\"[RAG] Indexed and chunked {f}\")\n                    except Exception as e:\n                        print(f\"[RAG] Failed to index {f}: {e}\")\n            time.sleep(5)\n\n    # NEW: summarize a doc with AI using its RAG context\n    def rag_summarize(self, fname):\n        fpath = str(self.rag_path / fname)\n        if fpath not in self.rag_chunks:\n            print(\"[RAG] File not indexed.\")\n            return\n        context = \"\\n\\n\".join(self.rag_chunks[fpath][:3])  # up to first 3 chunks\n        prompt = f\"Summarize this document:\\n{context}\"\n        self.run_ai(prompt)\n\n    # NEW: smarter context-aware search\n    def rag_search(self, query):\n        matches = []\n        for fname, chunks in self.rag_chunks.items():\n            for chunk in chunks:\n                if query.lower() in chunk.lower():\n                    matches.append((fname, chunk[:120]))\n        if matches:\n            print(\"[RAG Search] Found:\")\n            for fname, snippet in matches:\n                print(f\"  {fname}: ...{snippet}...\")\n        else:\n            print(\"[RAG Search] No match found.\")\n\n    # NEW: Reason mode (could be replaced with advanced agent)\n    def reason_mode(self, topic):\n        prompt = f\"You are Synapz, an autonomous system agent. Reason step by step about: {topic}\"\n        self.run_ai(prompt)\n\n    # ... rest unchanged (skills, shell, run_ai, etc.)\n\n