\nimport json\nfrom pathlib import Path\n\ndef vertex_parser(filepath):\n    # Accept any JSON file that looks like a Vertex/Gemini export\n    # Skip if not JSON or doesn't have expected keys\n    if not filepath.lower().endswith('.json'):\n        return []\n    with open(filepath, \"r\", encoding=\"utf-8\") as f:\n        try:\n            data = json.load(f)\n        except Exception:\n            return []\n    # Heuristic: must have \"messages\" (list) and \"model\" key\n    if not (isinstance(data, dict) and \"messages\" in data and isinstance(data[\"messages\"], list)):\n        return []\n    title = data.get(\"title\") or \"Vertex Conversation\"\n    model = data.get(\"model\", \"\")\n    out = []\n    messages = data[\"messages\"]\n    # Merge messages into conversation, preserving author and order\n    conversation_text = []\n    for m in messages:\n        author = m.get(\"author\", \"\")\n        content_obj = m.get(\"content\", {})\n        # For multi-part content (usual for Gemini export)\n        parts = []\n        if isinstance(content_obj, dict):\n            for part in content_obj.get(\"parts\", []):\n                if isinstance(part, dict):\n                    t = part.get(\"text\", \"\")\n                    if t:\n                        parts.append(t)\n        msg_text = \"\\n\".join(parts)\n        if msg_text.strip():\n            conversation_text.append(f\"{author.upper()}: {msg_text.strip()}\")\n    # Single chunk for whole conversation\n    if conversation_text:\n        out.append({\n            \"source\": \"vertex\",\n            \"title\": title,\n            \"text\": \"\\n\\n\".join(conversation_text),\n            \"date\": \"\",  # No clear timestamp in this format, add if present\n            \"metadata\": {\n                \"model\": model,\n                \"filename\": str(Path(filepath).name)\n            }\n        })\n    return out\n\ndef register(register_parser):\n    register_parser(vertex_parser)\n