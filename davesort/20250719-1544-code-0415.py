\nimport os\nimport sys\nimport queue\nimport threading\nimport time\nimport json\nfrom pathlib import Path\n\ntry:\n    import pyttsx3\nexcept ImportError:\n    pyttsx3 = None\n\n# ========== SYNAPZ CORE (real logic, not stub) ==========\nclass SynapzCore:\n    def __init__(self, memory_path=\"synapz_memory.json\"):\n        self.memory_path = memory_path\n        self.load_memory()\n        self.status = \"online\"\n        self.last_action = None\n\n    def load_memory(self):\n        if os.path.exists(self.memory_path):\n            with open(self.memory_path, \"r\") as f:\n                self.memory = json.load(f)\n        else:\n            self.memory = {\"logs\": [], \"facts\": {}, \"notes\": []}\n\n    def save_memory(self):\n        with open(self.memory_path, \"w\") as f:\n            json.dump(self.memory, f, indent=2)\n\n    def log(self, msg):\n        ts = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n        log_entry = f\"[{ts}] {msg}\"\n        self.memory[\"logs\"].append(log_entry)\n        self.save_memory()\n        return log_entry\n\n    def note(self, text):\n        self.memory[\"notes\"].append(text)\n        self.save_memory()\n        return f\"Noted: {text}\"\n\n    def remember(self, key, value):\n        self.memory[\"facts\"][key] = value\n        self.save_memory()\n        return f\"Remembered: {key} = {value}\"\n\n    def recall(self, key):\n        return self.memory[\"facts\"].get(key, \"No memory of that.\")\n\n    def status_report(self):\n        return {\n            \"status\": self.status,\n            \"last_action\": self.last_action,\n            \"notes\": self.memory[\"notes\"][-5:],\n            \"logs\": self.memory[\"logs\"][-5:]\n        }\n\n    def handle(self, command, context=None):\n        \"\"\"Main Synapz brain. Handles meta/agent/system commands.\"\"\"\n        cmd = command.lower().strip()\n        self.last_action = cmd\n\n        # Agent/system commands\n        if cmd.startswith(\"status\"):\n            return self.status_report()\n        if cmd.startswith(\"note \"):\n            return self.note(cmd[5:].strip())\n        if cmd.startswith(\"remember \"):\n            keyval = cmd[9:].strip().split(\"=\", 1)\n            if len(keyval) == 2:\n                return self.remember(keyval[0].strip(), keyval[1].strip())\n            else:\n                return \"Format: remember key = value\"\n        if cmd.startswith(\"recall \"):\n            key = cmd[7:].strip()\n            return self.recall(key)\n        if cmd.startswith(\"log \"):\n            return self.log(cmd[4:].strip())\n        if cmd == \"help\":\n            return (\n                \"SYNAPZ COMMANDS:\\n\"\n                \"  status       : Show agent status\\n\"\n                \"  note [text]  : Save a note\\n\"\n                \"  remember k=v : Save a fact\\n\"\n                \"  recall [k]   : Recall a fact\\n\"\n                \"  log [msg]    : Add to log\\n\"\n                \"  help         : Show this help\"\n            )\n        return f\"SynapzCore: I don't know how to '{cmd}'.\"\n\n# ========== JEMAI SHELL / CLI ==========\nclass JemaiShell:\n    def __init__(self):\n        self.synapz = SynapzCore()\n        self.tts = None\n        if pyttsx3:\n            self.tts = pyttsx3.init()\n        self.running = True\n\n    def say(self, text):\n        print(f\"\\n[SYNAPZ SAYS] {text}\")\n        if self.tts:\n            self.tts.say(text)\n            self.tts.runAndWait()\n\n    def run(self):\n        print(\"Welcome to JEMAI+SYNAPZ CLI. Type 'exit' to quit.\")\n        print(\"Type natural language or commands. Try: ls -l, remember foo=bar, note Hello, status\")\n        while self.running:\n            try:\n                cmd = input(\"\\nJEMAI> \").strip()\n                if not cmd:\n                    continue\n                # --- Universal quit ---\n                if cmd.lower() in (\"exit\", \"quit\"):\n                    self.say(\"Goodbye, Dave.\")\n                    break\n\n                # --- System command detection (auto-detect) ---\n                if self.is_shell_command(cmd):\n                    output = self.run_shell(cmd)\n                    self.say(output)\n                    continue\n\n                # --- Synapz agent auto-detect ---\n                if self.is_synapz_command(cmd):\n                    result = self.synapz.handle(cmd)\n                    self.say(result)\n                    continue\n\n                # --- Natural language mode: Let Synapz try, fallback to shell ---\n                if \"directory\" in cmd or \"list files\" in cmd:\n                    output = self.run_shell(\"ls -l\")\n                    self.say(output)\n                    continue\n\n                # Try AI memory recall\n                result = self.synapz.handle(cmd)\n                self.say(result)\n\n            except (KeyboardInterrupt, EOFError):\n                self.say(\"Shutting down JEMAI.\")\n                self.running = False\n\n    def is_shell_command(self, cmd):\n        # Heuristic: shell if starts with [a-z] and exists in $PATH, or obvious unix commands\n        tokens = cmd.strip().split()\n        if not tokens:\n            return False\n        # List of common commands to catch\n        unix_cmds = {\"ls\", \"cat\", \"cd\", \"rm\", \"mv\", \"cp\", \"pwd\", \"whoami\", \"ps\", \"df\", \"du\", \"chmod\", \"chown\", \"grep\", \"find\"}\n        if tokens[0] in unix_cmds:\n            return True\n        # Otherwise: check if cmd is executable in PATH\n        if shutil.which(tokens[0]):\n            return True\n        return False\n\n    def run_shell(self, cmd):\n        try:\n            result = os.popen(cmd).read()\n            if not result:\n                result = \"[no output]\"\n            return result.strip()\n        except Exception as e:\n            return f\"[ERROR running shell command: {e}]\"\n\n    def is_synapz_command(self, cmd):\n        # Keywords for Synapz to intercept\n        kw = (\"status\", \"note\", \"remember\", \"recall\", \"log\", \"help\")\n        return cmd.split(\" \",1)[0].lower() in kw\n\n# ========== MAIN ==========\nif __name__ == \"__main__\":\n    try:\n        import shutil\n        JemaiShell().run()\n    except Exception as e:\n        print(f\"[JEMAI FATAL ERROR]: {e}\")\n