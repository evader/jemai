\n# synapz_overlay.py - Unified Life Search Overlay (Step 969)\nimport tkinter as tk\nfrom tkinter import simpledialog, messagebox\nimport threading\nimport requests\nimport pyperclip\nimport keyboard  # pip install keyboard\nimport sys\n\n# ---- CONFIG ----\nAPI_USER = \"super\"\nAPI_PASS = \"TechnoAPI69\"\nAPI_ENDPOINTS = [\n    \"http://jemai.local:8089\",\n    \"http://localhost:8089\"\n]\nMAX_RESULTS = 5\n\n# ---- MEMORY API HELPER ----\ndef memory_search(query, limit=MAX_RESULTS):\n    for api in API_ENDPOINTS:\n        try:\n            resp = requests.get(\n                f\"{api}/search\",\n                params={\"q\": query, \"limit\": limit},\n                auth=(API_USER, API_PASS),\n                timeout=8\n            )\n            resp.raise_for_status()\n            results = resp.json().get(\"results\", [])\n            if results:\n                return results\n        except Exception as e:\n            print(f\"API fail at {api}: {e}\", file=sys.stderr)\n    return []\n\n# ---- SHELL EXEC (OPTIONAL, Windows only by default) ----\nimport subprocess\ndef shell_exec(cmd):\n    try:\n        output = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT, universal_newlines=True, timeout=8)\n        return output[:1500]  # Limit size\n    except Exception as e:\n        return f\"Shell error: {e}\"\n\n# ---- GUI ----\nclass SynapzOverlay(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"Synapz Unified Search\")\n        self.geometry(\"650x80+400+300\")\n        self.configure(bg=\"#101026\")\n        self.attributes(\"-topmost\", True)\n        self.resizable(False, False)\n        self.overrideredirect(True)  # No window chrome\n\n        # Entry\n        self.entry = tk.Entry(self, font=(\"Consolas\", 16), width=55, bg=\"#1a1a2b\", fg=\"#e0e0ff\", insertbackground=\"#e0e0ff\")\n        self.entry.pack(padx=15, pady=10)\n        self.entry.bind(\"<Return>\", self.run_query)\n        self.entry.bind(\"<Escape>\", lambda e: self.close())\n        self.entry.bind(\"<Down>\", self.focus_listbox)\n        self.entry.focus()\n\n        # Listbox for results\n        self.listbox = tk.Listbox(self, font=(\"Consolas\", 12), width=60, height=4, bg=\"#1a1a2b\", fg=\"#aaaaff\")\n        self.listbox.pack(padx=15, pady=(0,10))\n        self.listbox.bind(\"<Return>\", self.copy_selected)\n        self.listbox.bind(\"<Escape>\", lambda e: self.close())\n        self.listbox.bind(\"<Double-Button-1>\", self.copy_selected)\n        self.results = []\n\n        # Focus trick\n        self.after(50, lambda: self.entry.focus_force())\n\n    def focus_listbox(self, event):\n        if self.results:\n            self.listbox.focus_set()\n            self.listbox.selection_set(0)\n\n    def run_query(self, event=None):\n        query = self.entry.get().strip()\n        self.listbox.delete(0, tk.END)\n        self.results = []\n        if not query:\n            return\n        if query.startswith(\"JEMAI-SEARCH::\"):\n            search_q = query[len(\"JEMAI-SEARCH::\"):].strip()\n            self.results = memory_search(search_q)\n            if self.results:\n                for r in self.results:\n                    text = f\"{r['title'] or '[no title]'} | {r['source'] or '[src]'}\\n{r['text'][:100].replace('\\n',' ')}...\"\n                    self.listbox.insert(tk.END, text)\n            else:\n                self.listbox.insert(tk.END, \"No results found.\")\n        elif query.startswith(\"JEMAI-CMD::\"):\n            cmd = query[len(\"JEMAI-CMD::\"):].strip()\n            out = shell_exec(cmd)\n            self.results = [{\"text\": out, \"title\": \"Shell Output\", \"source\": \"local\"}]\n            self.listbox.insert(tk.END, out if len(out) < 120 else out[:120]+\"...\")\n        elif query.startswith(\"JEMAI-ACTION::\"):\n            self.listbox.insert(tk.END, \"Agent actions not yet implemented (future: call agent API here)\")\n        else:\n            # Default: memory search\n            self.results = memory_search(query)\n            if self.results:\n                for r in self.results:\n                    text = f\"{r['title'] or '[no title]'} | {r['source'] or '[src]'}\\n{r['text'][:100].replace('\\n',' ')}...\"\n                    self.listbox.insert(tk.END, text)\n            else:\n                self.listbox.insert(tk.END, \"No results found.\")\n\n    def copy_selected(self, event=None):\n        idx = self.listbox.curselection()\n        if not idx:\n            idx = (0,)\n        if self.results and idx[0] < len(self.results):\n            out = self.results[idx[0]][\"text\"]\n            pyperclip.copy(out)\n            self.close()\n        else:\n            self.close()\n\n    def close(self):\n        self.destroy()\n\ndef launch_overlay():\n    overlay = SynapzOverlay()\n    overlay.mainloop()\n\ndef hotkey_loop():\n    print(\"Hotkey listener active! Press Ctrl+Shift+Space to launch Synapz overlay.\")\n    keyboard.add_hotkey(\"ctrl+shift+space\", launch_overlay)\n    keyboard.wait()  # Blocks forever\n\nif __name__ == \"__main__\":\n    t = threading.Thread(target=hotkey_loop, daemon=True)\n    t.start()\n    # Keep alive for hotkey, but also allow run as script\n    while True:\n        time.sleep(3600)\n